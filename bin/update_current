#!/usr/bin/env ruby

require 'open3'
require 'timeout'
require 'json'
require 'logger'
require 'cli'
require 'net/http'
require 'uri'
require 'json'

def get_cf_deployed_versions(deployment:)
  target = ENV['BOSH_DIRECTOR']
  ca_cert = ENV['BOSH_CA_CERT_PATH']

  token_decoder = Bosh::Cli::Client::Uaa::TokenDecoder.new
  director_client = Bosh::Cli::Client::Director.new(target, nil, ca_cert: ca_cert)
  auth_info = Bosh::Cli::Client::Uaa::AuthInfo.new(director_client, ENV, ca_cert)
  token_provider = Bosh::Cli::Client::Uaa::TokenProvider.new(auth_info, nil, token_decoder, target)
  credentials = Bosh::Cli::Client::UaaCredentials.new(token_provider)
  auth_director = Bosh::Cli::Client::Director.new(target, credentials, { ca_cert: ca_cert })

  deployments = auth_director.list_deployments
  deployment_details = deployments.select {|d| d['name'] == deployment}.first

  return deployment_details
end


def get_bosh_director_deployed_versions(deployment:)
  director = ENV['BOSH_DIRECTOR'].sub("bosh", "micro")
  bosh_user = ENV['BOSH_USER']
  bosh_password = ENV['BOSH_PASSWORD']

  uri = URI.parse("#{director}/deployments")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_NONE
  request = Net::HTTP::Get.new(uri.request_uri)
  request.basic_auth(bosh_user, bosh_password)

  response = http.request(request)
  deployments = JSON.parse(response.body)
  deployment_details = deployments.select {|d| d['name'] == deployment}.first

  return deployment_details
end

def extract_releases_and_stemcells(deployment_details, releases)
  stemcell_version = deployment_details['stemcells'].first

  final_output = deployment_details['releases'].each_with_object([]) do |release_hash, memo|
    if releases.include?(release_hash['name'])
      memo << { 'release' => release_hash, 'stemcell' => stemcell_version}
    end
  end

  final_output
end

def logger
  logger ||= Logger.new($stderr)
end

def main
  cf_deployment_info = get_cf_deployed_versions(deployment: 'cf-cfapps-io2-diego')
  bosh_deployment_info = get_bosh_director_deployed_versions(deployment: 'vpc-bosh-run-pivotal-io')

  deployed_versions = extract_releases_and_stemcells(cf_deployment_info, ['cf', 'diego', 'grootfs', 'garden-runc', 'cflinuxfs2'])
  deployed_versions.sort! {|i,j| i['release']['name'] <=> j['release']['name'] }

  deployed_versions += extract_releases_and_stemcells(bosh_deployment_info, ['bosh'])

  ## for every release specified above, make sure there is an entry for each release in release_repos.json
  ## this updates the link in the statuspage to the correct github URL
  release_repos = JSON.parse(IO.read 'release_repos.json')
  deployed_versions.map do |release_hash|
    release_repo_url = release_repos[release_hash['release']['name']]
    raise "release not found in release_repos.json, please add before continuing" if release_repo_url.nil?
    updated_release_version = release_hash['release']['version']

    updated_release_repo_url = release_repo_url + updated_release_version
    release_hash['release']['notes'] = updated_release_repo_url
  end

  result = JSON.pretty_generate(deployed_versions)
  IO.write('current.json', result)
  logger.info("wrote #{result} to current.json")
end

main
